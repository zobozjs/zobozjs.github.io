"use strict";(self.webpackChunkzobozjs_website=self.webpackChunkzobozjs_website||[]).push([[3552],{1184:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var i=s(4041);const t={},o=i.createContext(t);function l(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(o.Provider,{value:n},e.children)}},2329:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"learn/avoid-pkg-type","title":"avoid-pkg-type","description":"The type field in package.json can cause unintended compatibility issues across different module systems. While it may seem like a simple setting, it can impact how Node.js, bundlers, and other tools interpret your package.","source":"@site/docs/learn/avoid-pkg-type.md","sourceDirName":"learn","slug":"/learn/avoid-pkg-type","permalink":"/docs/learn/avoid-pkg-type","draft":false,"unlisted":false,"editUrl":"https://github.com/zobozjs/zoboz/tree/main/packages/zobozjs-website/docs/learn/avoid-pkg-type.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"avoid-pkg-type","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/learn/intro"},"next":{"title":"missing-runtime-deps","permalink":"/docs/learn/missing-runtime-deps"}}');var t=s(1085),o=s(1184);const l={title:"avoid-pkg-type",sidebar_position:2},r="Why You Should Avoid the type Field in package.json",d={},c=[{value:"Why Is It Harmful?",id:"why-is-it-harmful",level:2},{value:"1. It Alters Module Resolution Unexpectedly",id:"1-it-alters-module-resolution-unexpectedly",level:3},{value:"2. It Interferes with the <code>main</code> and <code>module</code> Fields",id:"2-it-interferes-with-the-main-and-module-fields",level:3},{value:"3. Tooling Conflicts",id:"3-tooling-conflicts",level:3},{value:"Recommendation",id:"recommendation",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsxs)(n.h1,{id:"why-you-should-avoid-the-type-field-in-packagejson",children:["Why You Should Avoid the ",(0,t.jsx)(n.code,{children:"type"})," Field in ",(0,t.jsx)(n.code,{children:"package.json"})]})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"type"})," field in ",(0,t.jsx)(n.code,{children:"package.json"})," can cause unintended compatibility issues across different module systems. While it may seem like a simple setting, it can impact how Node.js, bundlers, and other tools interpret your package."]}),"\n",(0,t.jsx)(n.h2,{id:"why-is-it-harmful",children:"Why Is It Harmful?"}),"\n",(0,t.jsx)(n.h3,{id:"1-it-alters-module-resolution-unexpectedly",children:"1. It Alters Module Resolution Unexpectedly"}),"\n",(0,t.jsxs)(n.p,{children:["When you set ",(0,t.jsx)(n.code,{children:'"type": "module"'}),", Node.js assumes all ",(0,t.jsx)(n.code,{children:".js"})," files are ESM, which can break CommonJS consumers expecting ",(0,t.jsx)(n.code,{children:".js"})," to be CommonJS."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ESM Consumers"}),": May mistakenly treat CommonJS as an ES module."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CommonJS Consumers"}),": May fail to import files correctly."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Likewise, setting ",(0,t.jsx)(n.code,{children:'"type": "commonjs"'})," forces everything to be treated as CommonJS, which can create issues when trying to support both module types."]}),"\n",(0,t.jsxs)(n.h3,{id:"2-it-interferes-with-the-main-and-module-fields",children:["2. It Interferes with the ",(0,t.jsx)(n.code,{children:"main"})," and ",(0,t.jsx)(n.code,{children:"module"})," Fields"]}),"\n",(0,t.jsxs)(n.p,{children:["Many libraries specify ",(0,t.jsx)(n.code,{children:"main"})," and ",(0,t.jsx)(n.code,{children:"module"})," fields for compatibility:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "main": "./dist/cjs/index.js",\n  "module": "./dist/esm/index.js"\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"type"})," is set, Node.js may ignore one of these fields depending on context, breaking compatibility for some consumers."]}),"\n",(0,t.jsx)(n.h3,{id:"3-tooling-conflicts",children:"3. Tooling Conflicts"}),"\n",(0,t.jsxs)(n.p,{children:["Not all tools interpret ",(0,t.jsx)(n.code,{children:"type"})," consistently:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Webpack, Babel, and TypeScript"}),": May not respect ",(0,t.jsx)(n.code,{children:"type"}),", leading to incorrect bundling or transpilation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ESLint and other linters"}),": May apply incorrect rules."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testing frameworks"}),": May fail to properly resolve modules."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"recommendation",children:"Recommendation"}),"\n",(0,t.jsxs)(n.p,{children:["Unless absolutely necessary, ",(0,t.jsxs)(n.strong,{children:["remove the ",(0,t.jsx)(n.code,{children:"type"})," field"]})," and instead use explicit file extensions (",(0,t.jsx)(n.code,{children:".cjs"})," and ",(0,t.jsx)(n.code,{children:".mjs"}),") to define module types. This avoids ambiguity and ensures compatibility across all environments."]}),"\n",(0,t.jsxs)(n.p,{children:["For more details, refer to the ",(0,t.jsx)(n.a,{href:"https://nodejs.org/api/packages.html#packages_type",children:"Node.js documentation"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);